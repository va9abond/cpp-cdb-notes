- `noexcept` C++11

  Функция помечается спецификатором `noexcept`, если она не
  выбрасывает исключения и любая функция функция, которую она вызывает
  тоже не выбрасывает исключения

- `noexcept(consteval_bool_pred)` C++11
  - Предикат должен быть вычисляемым во время компиляции
  - `noexcept(true)` эквивалентен `noexcept`
  - `noexcept(false)` эквивалентен отсутствию спецификатора

- `operator noexcept(expr)`

  Этот оператор возвращает `true`, если:
  - `expr` не содержит вызов оператора `new`
  - `expr` не содержит `dynamic_cast`
  - `expr` не содержит вызов функции, которая выбрасывает исключения

  ```cpp
  template <typename T> void foo (T& x) noexcept( noexcept(g(x)) )
  {
    g(x);
  }
  ```

- function-try block  
  Пусть у нас следующая ситуация:
  ```cpp
  class Y {
      Y (const Bar& other) : bar(other) {}
      Bar bar;
  };
  ```

  И исключение вылетает в списке инициализации конструктора
  `bar(other)`, кто тогда будет ловить это исключение? Есть
  возможность ловить это исключение прямо в месте вызова `bar(other)`.
  Это позволяет сделать *function-try block*:
  ```cpp
  void foo() try {
      ...
  } catch (...) {
      ...
  }
  ```
  Этот синтаксис эквивалентен тому, что вызов функции `foo()`
  помещается внутрь `try`-блока. `try-catch`. Пример выше можно
  переписать так:
  ```cpp
  class Y {
      Y (const Bar& other) : bar(other) try {
          // ctor body
      } catch (...) {
          ...
      }
      Bar bar;
  };
  ```

# Allocators
## Общая форма оператора `new`

Что происходит при вызове опертора `new`: `T* ptr = new T(args)`
- Обращение к операционной системе, чтобы она выделила в куче
столько памяти, сколько необходимо для хранения одного объекта типа
`T`: `sizeof(T)`.
- Вызов соответствующего переданным аргументам `args` конструктора для
типа `T` на той, памяти, которую ему дала операционная система
- Возврат указателя на эту память

У оператора `new` есть еще одна распространенная форма - *placement
new*. Она необходима, когда нужно сконструировать объект на уже
выделенном участке памяти (типа функции `emplace`). Например,
это необходимо для `vector.push_back(...)`.  В этом
случае, память для нового элемента уже выделена и нужно только
сконструировать объект в этой памяти.

**Пример**. Возможно мы хотим сделать так:
```cpp
*(arr+sz) = value;
```

**Проблема!** Когда мы так пишем, мы фактически вызываем
оператор присваивания, но от несуществующего левого агрумента ведь там
пустая память. Если подробнее, то `arr+sz` имеет тип `T*` - указатель
на начало массива, сдвинутый на `sz` штук вправо - это
неинициализированная память, следовательно, `*(arr+sz)` -
разъименование неинициализирванной памяти - **UB**.

Итак, *placement new*: `new(T_ptr) T(args)`, где `T_ptr` это указатель
на то место в памяти, на котором нужно вызвать конструктор для объекта
`T` с аргументами `args`.

Тогда `vector.push_back(...)` может быть реализован так:
```cpp
void push_back (const T& value)
{
  ...
  new(arr+sz) T(value);
}
```

*Недостаток*: может получиться так, что мы будем вызывать этот `push_back` на
серверах, где память устроенна как-то хитро.

> [!NOTE]
  Может быть так, что у нас нет стандартного пулла, откуда берется
  память, поэтому обобщенный контейнер не должен лезть сразу к
  системному `new`. Здесь у нас должен быть какой-то промежуточный
  распределитель памяти, который будет давать память под контейнер.
  И здесь мы приходим к *аллокаторам*.

## Перегрузка оператора `new`

Любая форма оператора `new` по дефолту делает две вещи:
- вызывает функцию `operator new` с переданными аргументами
- вызывает конструктор на том месте, которое вернул глобальный `new`
(**не может быть переопределено**)


> [!IMPORTANT]
  Вторая часть работы любого оператора `new` не может быть
  переопределена.

Тогда *placement new* отличается от обычного оператора `new` тем, что
в первой части у обычного оператора `new` вызывается функция
`operator new` с нужным количеством байт, а *placement new* в него
передает еще один параметр (т.е. всего их 2) - указатель на место,
куда нужно направить конструктор. А `operator new` с двумя
параметрами переопреден так, что он ничего не делает, и
`operator new` с одним параметром делает какой-то системный вызов,
чтобы ему дали память (Если я буду сам его реализовывать, то я могу
использовать для этого `malloc`).

### Глобальная перегрузка

> [!IMPORTANT]
  Есть глобальный оператор `new`, а есть функция, которая называется
  `operator new`, это разные вещи! Функция вызывается внутри
  глобального оператора перед тем, как последний вызовет конструктор
  для типа. Т.е. функция `operator new` это и есть первая часть
  оператора `new`

Мы можем переопределить функцию `operator new` глобально, например,
для того, чтобы отследить все динамические выделения памяти - в каждом
вызове оператора кидать информацию в логи
```cpp
void* operator new (size_t n)
{
  std::cout >> "[INFO] allocate " << n << " bytes" << '\n';
  ...
}
```

> [!NOTE]
  `void *` это указатель на сырую память

Такое переопределение функции `operator new` будет означать, что ВСЕ
вызовы `new` в программе, будут проходить через вашу переопределенную
функцию `operator new`

> [!WARNING]
  В переопределенном `operator new` нельзя вызывать `new` - получим
  рекурсивное зацикливание, вместо этого, например, можно использовать
  `malloc`

Стандартная реализация *placement new* выглядит так:
```cpp
T* operator new (size_t n, T* ptr)
{
  return ptr;
}
```

Но мы можем переопределить функцию `new` с другим набором параметров:
```cpp
T* operator new (size_t n, args)
```
А после вызывать ее так: `... new(args) T(...)`

### Перегрузка внутри класса

Перегрузка функции `operator new` может быть и внутри класса, тогда
все вызовы `new` для вашего класса будут проходить через вашу
переопределенную функцию `operator new`

### Перегрузка `new[]` (??)

Оператор `new[]` это еще одна форма опертора `new`. Она делает все
тоже самое, что обычный `operator new`.

**Пример**
```cpp
new char[n*sizeof(T)];
```

Если мы его переопределяем глобально:
```cpp
T* operator new[] (size_t n, T* ptr)
{
  ...
}
```
то параметр `n` попрежнему обозначает количество байт

А если мы определяем его внутри класса, то параметр `n` обозначает
количество элементов типа `T`

## `nothrow` форма оператора `new`

Эта версия оператора `new` отличается от предыдущих тем, что она
никогда не выбрасывает исключения
```cpp
new (std::nothrow) T(...)
```

Ее реализация может выглядеть так:
```cpp
namespace std {
  struct nothrow_t { };
  nothrow_t nothrow; // sizeof(nothrow) = 1

  T* operator new (size_t n, nothrow_t nothrow) noexcept
  {
    ... // do not throw any exception in func body
  }
} // namespace std
```

## Оператор `delete`

Есть оператор `delete`, который состоит из двух частей:
- функция `operator delete`
- вызов деструктора (**нельзя переопределять**)

> [!WARNING]
  Когда мы вызываем оператор `delete`: `delete p;`. То сначала,
  вызывается деструктор, а только потом функция `operator delete`.
  Деструктор вызывается всегда (с одной оговоркой). В C++20 появился
  оператор `delete`, который деструктор не вызывает, до этого
  избежать вызова деструктора было невозможно, например, для того,
  чтобы вызывать какую-то функцию, вызывающую деструктор

> [!TIP]
  Как запретить создавать объекты своих классов на стеке?\
  Задача, может быть решена только в C++20. Для этого нужно объявить
  деструктор приватным, а функцию `operator delete` переопределить
  так, чтобы она вызывала публичную функцию класса, которая в свою
  очередь вызовет деструктор

Как устроена глобальная функция `operator delete`:
```cpp
operator delete (void* p, size_t n)
{
  ... // free memory
}
```
Параметр `p` указывает на объект, память из под которого нужно
освободить, а параметр `n` количество байт, которые нужно
освободить, т.е. `n = sizeof(T)`

Глобальная функция `operator delete[]`
```cpp
void operator delete[] (void* p, size_t n)
{
  ... // free memory
}
```
Параметр `p` снова указывает на объект, память из под которого нужно
освободить, а параметр `n` количество объектор в массиве, которые
нужно освободить

> [!WARNING]
  Функция `operator delete` не может вызывать деструктор объекта,
  потому что это делает оператор `delete` еще до того, как будет
  вызвана функция `operator delete` (кроме случая, когда деструктор
  приватный)

> [!TIP]
  Обычно мы вызывает оператор `delete[]` так: `delete[] arr;`.\
  Как компилятор понимает, сколько объектов в качестве параметра `n`
  нужно передать в функцию `operator delete[] (void*, size_t)`?\
  На самом деле, компилятор во время вызова оператора `new[]`
  компилятор запоминает количество элементов, память для которых он
  выделил. При вызове `new[n]` компилятор запрашивает чуть больше
  памяти для того, чтобы дополнительно сохранить количество элементов
  `n`, и компилятор помнит об этом количестве, когда вызывается
  оператор `delete[]`

Можно переопределить функцию `operator delete` для разных параметров.
Или для вашего класса, но нужно не забыть, что внутри класса он должен
быть определен как статическая функция

> [!IMPORTANT]
  Функции `operator new`, `operator new[]`, `operator delete`,
  `operator delete[]`, которые мы переопределяем внутри класса, должны
  быть статическими функциями[^1], потому что они не относятся ни к какому
  объекту напрямую (нельзя делать так: `obj.new(...)`), они относятся
  ко всему классу

[^1]: Статическая функция это функция, которая не является методом
объекта, она является методом класса (методом для типа) - это нечто
общее для всех объектов данного класса

Пусть, например, у меня есть класс `Base`, от которого унаследован
класс `Derived`. У каждого из них определен своя собственная
функция `operator delete`. Далее мы делаем так:
```cpp
Base* bp = new Derived(...);
delete bp;
```
Если деструктор базового класса виртуальный, то вызов деструктора
внутри оператора `delete` будут правильный (вызовется деструктор
класса `Derived`), а как сделать так, чтобы и последующий после
этого вызов функции `operator delete` оказался правильным?
Составители стандарта указали в нем, что при наличии виртуального
деструктора и пользовательской функции `operator delete` компилятор
сам обязан проследить, чтобы функция `operator delete` тоже была
вызвана из нужного класса. А при этом мы должны понимать, что мы **не
можем одновременно объявить функцию** `operator delete` **как
статическую и виртуальную**
