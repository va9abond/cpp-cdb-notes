# 3. Объектно-ориентированное счастье
## 3.1 Икапсуляция и игра в мячик

Разработаем тип данных для моделирования полета мяча в друмерном мире.
- Мяч может лететь свободно: `fly(double t)`
- Мяч можно толкнуть, придав ему скорость под углом:
  `push(double v, double alpha)`

Начнем с реализации (1)
```cpp
struct ball_t {
  void push (double v, double alpha);
  void fly (double time);

  double t;
  double vx;
  double vy;
  double x;
  double y;
};
```

Проблемы:
- Любой пользователь типа `ball_t` может менять поля объекта, что
  может приводить к тому, что поведение мяча может не соответствовать
  модели, например, в плохо отлаженной программе он может
  телепортироваться
- Если нам понадобиться запустисть этот мяч в многопользовательской
  среде, то для того, чтобы вставить синхронизацию, придется переписать
  каждый участок кода, где ссылались на поля класса[^1]

[^1]: ?? зачем переписывать и как переписывать?

### 3.1.1 Конкретные классы

*Конкретными классами* называются простые классы без полиморфизма и
наследования.

Реализация (2)
```cpp
struct ball_t {
public:
  void push (double v, double alpha);
  void fly (double time);

prvate:
  double m_t;
  double m_vx;
  double m_vy;
  double m_x;
  double m_y;
};
```

- Модификатор `public` означает, что любой пользователь типа `ball_t`
  имеет доступ к этим методам или данным
- Модификатор `private` означает, что доступ к этим методам и данным
  имеют только методы этого класса (или друзья класса)
- Хороший тон - закрывать данные, составляющие состояние объекта и
  открывать функции, составляющие его поведение

**Вопрос** Если нам доступны методы, открывающие к полю класса чтение
и запись, то не лучше ли вынести это поле `color_` в открытую часть?
```cpp
struct colored_ball_t {
public:
  int get_color() { return color_; }
  void set_color (int color) { color_ = color; }

private:
  int color_;
  // all other
}
```
**Ответ**

**Вопрос** Стрем или норм?
```cpp
struct Bar {
private:
  int foo (int);

public:
  int foo (char);
}

Bar b;
b.foo(1);
```
**Ответ** Целочисленный литерал `1` имеет тип `int`, поэтому
вызовается именно закрытый метод `foo(int)`. А правильно ли позволять
программистам так делать, я не знаю.

### 3.1.2 POD и NPOD типы

- Типы со специальным созданием
- Типы со специальным поведением при копировании
- Типы с неизвестным или зависящим от реализации размером
- и тд.

Стандарт (C++14, раздел 9) определяет следующие термины для
обозначения категорий типов, объекты которых могут быть созданы:
- *Тривиально копируемый*
  - непрерывен в памяти
  - не обладает специальным поведением про копировании
  - для таких типов работает `memcpy` и `memmove`
- *Тривиальный*
  - тривиально копируемый
  - без спициального поведения при создании
- *Со стандартным расположением полей*
    - нет зависящих от реализации полей (члены-ссылки, таблицы
      виртуальных методов и тд)
    - такие типы удобны для передачи в модули, написанные на других
      языках, т.к. их всегда можно десериализовать[^2] независимым от
      языка и компилятора образом
- *POD (plain old data)*
  - тривиально копируемый тип со стандартным расоположением полей
- *NPOD (not plain old data)*
  - все, что не является POD типом

[^2]: что это такое?

Типы с закрытой частью остаются тривиально копируемыми.

### 3.1.3 Инициализация и уничтожение

Если мы не имеем прямого доступа к полям объекта, то при создании
объект сам должен установить свое состояние, а при уничтожении -
освободить выделенные ресурсы. Для это в класс вводятся конструкторы и
деструктор - специальные функции, вызывающиеся при создании и
уничтожении объекта.

```cpp
ball_t (double a_x = 0.0, double a_y = 0.0):
  m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0) {}

~ball_t() {}
```

`m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0)` - называется
*списком инициализации*

Инициализацию можно написать и в теле конструктора, но лучше
использовать список инициализации[^3]

[^3]: почему?

Новизна операторов `new` и `delete` в том, что кроме выделения памяти
на куче, `new` вызывет конструктор, `delete` - деструктор. В отличие
от `malloc`, который только выделит память.
```cpp
ball_t* pball = new ball_t(1.0, 2.0);
// use pball
delete pball;
```

Чтобы получить двадцать мячиков на куче, инициализированных по
умолчанию, вызывается оператор `new[]`, который вызывает конструкторы
для ВСЕХ этих объектов, а еще записывает количество объектор в
специальные структуры памяти, чтобы последующий вызов `delete[]` знал,
сколько деструкторов вызывать.
```cpp
ball_t* pballs = new ball_t[20];
// use pballs
delete[] pballs;
```

Выделение памяти и вызов конструктора неразрывны, но
размещающий оператор `new` *(placement new)*, позволяет обойти это
правило.

Часто, конструкторы класса делают почти одно и тоже. В этом случае,
начиная с C++11, конструкторы можно *делегировать*, т.е. вызвать
конструктор этого же класса из списка инициализации:
```cpp
class X {
  int a;
public:
  X (int x) : a(x) { /* ... some logic ... */ }
  X (double x) : X(static_cast<int>(x)) { }
};
```

Если инициализация списком утомительна, начиная с C++11 можно
использовать *инициализацию в теле класса*.
```cpp
class A {
  int a = 7;
  int b = 5;
public:
  A() {} // sets a = 7, b = 5
  A(int x) : a(x) {} // sets b = 5
};
```

Неожиданно сложным является вопрос о том, что делать, если в
конструкторе произошла ошибка. Короткий ответ: использовать
инсключения.

### 3.1.4 Неявное преобразование типов и `explicit`

Конструкторы помимо создания объекта класса напрямую используются и
для неявных преобразований типов. Неявные преобразования в C
называются *type promotions*, и некоторые из них действуют и в C++.
```
anytype 'op' long double => long double 'op' long double
anytype 'op' double => double 'op' double
anytype 'op' float => float 'op' float
anytype 'op' unsigned long long => unsigned long long 'op' unsigned long long
anytype 'op' long long => long long 'op' long long
anytype 'op' unsigned long => unsigned long 'op' unsigned long
anytype 'op' long => long 'op' long
anytype 'op' unsigned int => unsigned int 'op' unsigned int
anytype 'op' int => int 'op' int
```

Конструкторы с одним аргументом (считая аргументы по умолчанию
частично подставляемые всюду кроме первого аргумента) можгут быть
использованы компилятором для неявного преобразования от типа
аргумента к типу класса. Но это может иметь неприятные последствия:
```cpp
int emulate_ball (ball_t b);

int foo() {
  emulate_ball(1.0); // bad, but legal
}
```

Ключевое слово `explicit` перед конструктором запрещает компилятору
использовать неявные преобразования из типа аргумента конструктора к
типу класса.
```cpp
explicit ball_t (double a_x = 0.0, double a_y = 0.0):
  m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0) {}
```

Лепить `explicit` куда ни поподя - дурной тон, например, это ключевое
слово возможно в конструкторе с более чем одним аргументом или без
аргументов, но совершенно там не нужно.

### 3.1.5 Value-инициализация и Default-инициализация

Тривиальные и нетривиальные типы требуют разной обработки во время
веделения памяти. Когда пользователь пишет
```cpp
int *t = new int; // t uninitialized
int *ts = new int[10]; // pt[.] uninitialized
```
Он не ожидает, что будет вызвано десять конструкторов для целых чисел.
Ожидаемое поведение - десять неинициализированных объектов.
В этом случае никакого конструктора вызвано не будет.
```cpp
struct Triv {
  int x
};

Triv *px = new Triv; // x uninitialized
```

Если явно добавить деструктор в структуру, то она перестает быть
тривиальной и для нее будет сгенирирован конструктор по умолчанию.
```cpp
struct NTriv {
  int x;
  ~NTriv() {;}
};

NTriv *px = new NTriv; // x initialized with 0
```

Для того, чтобы у тривиальных типов тоже вызывался конструктор
предусмотрели указание пустых скобок для *value-initialization*
```cpp
struct Triv {
  int x;
};

Triv *px = new Triv(); // x initialized with 0
int *t = new int(); // t initialized with 0
int *ts = new int[10](); // 10 ints are initializeda with 0
```

С одной стороны, мы получили запутанность, с другой стороны - аналог
`calloc` для всех тривиальных типов

### 3.1.6 Селекторы

Нужны методы, сохраняющие состояние мяча, но позволяющие прочитать
его. Такие методы называются *селекторами*.
```cpp
double get_x() const { return m_x; }
double get_y() const { return m_y; }
```

`const` в определении указывает, что изменение любого поля класса
внутри метода вызовет ошибку компиляции. Исключением составляют поля,
объявленные с ключевым словом `mutable`, ими не стоит злоупотреблять в
проектировании.

**Вопрос** Найти нетривиальный случай, когда ключевое слово `mutable`
полезно и оправдано.

Лучше делать селектором любой метод, который может быть селектором
теоретически и который не должен менять внутреннего состояния объекта.
Это позволяет дополнительные оптимизации в компиляторе и аннотирует
метод важной информацией для дальнейшего использования.

### 3.1.7 Статические члены в классе

Каждый объект класса имеет свои собственные копии полей класса
`this->x`. Именно поэтому методы структуры и класса неявно берут
первым аргументом указатель на тот объект, для которого они будут
вызваны, а иначе как они поймут с полями какого из объектов класса
взаимодействовать.

И все же, иногда нужно иметь общий атрибут[^4] для всех объектов. В
этом случае используют ключевое слово `static`, которое в контексте
класса обозначает, что методы и данные не зависят от `this` и являются
общими для всех объектов класса.

[^4]: Атрибут - данные класса, образующие его состояние (это может
    быть поле или метод).

```cpp
class ball {
  int x, y;
  static int ball_count;

public:
  ball() : x(0), y(0) {
    ball_count += 1;
  }

  static int get_count() {
    return ball_count;
  }
}; int ball::ball_count = 0;
```

Статический метод класса `get_count()` не отмечен как `const`.
Статические методы не могут быть отмечены ключевым словом `const`,
потому что поскольку у таких методов нет объекта класса, они не могут
изменять состояние ни одного объекта.

Статические методы класса не сильно отличаются от глобальных. У первых
есть доступ к закрытому *статическому* атрибуту. Точно так же и
статические поля не сильно отличаются от глобальных переменных.

Статические поля должны быть инициализированны вне класса, этого
нельзя делать в конструкторе, потому что статические члены должны быть
доступны, даже если не было создано ни одного объекта.

Дополнительное определение где-то вне класса требутеся даже если
инициализация не требуется.
```cpp
struct S {
  statix int x;
};

int S::x;
```
Это связано с тем, что в конструкторе выделение памяти для полей
объектов класса и их полей не происходит (это случается в операторе
`new` перед тем, как конструктор будет вызван), но память должна
где-то быть выделена. Надо быть осторожнее с ODR - плохая идея делать
это в заголовочнике[^5].

[^5]: почему?

Исключение сделано для статических констант внутри класса. Они могут
быть инициализированны по месту объявления.

### 3.1.8 Указатели на методы класса

Пусть мы имеем класс:
```cpp
struct MyClass {
  int do_it (float a, float b) const;
};
```
Тогда тип *указатель на константный метод* может быть записан:
```cpp
typedef int (MyClass::*do_it_ptr)(float, int) const; // (var. 1)
using do_it_ptr = int (MyClass::*)(float, int) const; // (var. 2)
```
Звездочка после `::` является частью синтаксиса. А теперь может это
использовать:
```cpp
do_it_ptr ptr = &MyClass::do_it;
MyClass c;
(c.*ptr)(1.0, 0);

// or

MyClass *d = &c;
(d->*ptr)(1.0, 0);
```

### 3.1.9 Объявления и определения классов

*Объявление* класса как неполного типа:
```cpp
class ball_t;
```
С этого момента тип `ball_t` можно использовать по правалам (из
стандарта) для неполных типов.

*Определение* класса - это объвление всех его методов и полей. Но
внутри определения класса, каждое объявление поля, стат. поля или
метода - это *объявление*.
- Определением нестат. члена - конструктор клсса;
- Определение метода может встречаться как внутри класса, так и быть
  вынесено вне его;
- Определение статического объекта всегда должно быть вне класса.

## 3.2 Классы для управления ресурсами

**Вопрос** Какие есть ресурсы кроме динамической памяти?

Что общего у всех этих ресурсов? Как правило - наличие парных команд
для запроса и освобождения, например:
- `new` и `delete` для динамической памяти;
- `fopen` и `fclose` для файлов;
- `mysql_real_connect` и `mysql_close` для запросов MySQL C API;
- `pthread_mutex_init` и `pthread_mutex_destroy` для работы с
  мьютексами в POSIX.
В общем случае можно говорить о паре функций: `query` для запроса
ресурса и `release` для освобождения ресурса.

**Пример**
```cpp
int foo (int n) {
  int *a = new int[n];
  res_t other = query();

  // some logic

  if (condition) {
    delete[] a;
    release (other);
    return FAILURE;
  }

  // some logic

  delete[] a;
  release (other);
  return SUCCESS;
}
```
Проблема в том, что код освобождения ресурсов дублируется и часто в
непредсказуемых местах. Какие решения этой проблемы используют в
_legacy code_ на языке C.

- Лучший выход, применяемый в ядре Linux, это использование в таких
  случаях `goto`
  [(link)](https://www.kernel.org/doc/Documentation/process/coding-style.rst).
  ```cpp
  int *a = new int[n];
  res_t other = query();
  int error_code = SUCCESS;

  // some logic

  if (condition) {
    error_code = FAILURE;
    goto cleanup;
  }

  // some logic

  cleanup:
  delete[] a;
  release(other);

  return error_code;
  ```
- Другая реализация этого подхода это использовать `do-while`, который
  позволяет организовать `goto` без явного `goto`.
  ```cpp
  int *a = new int[n];
  res_t other = query();
  int error_code = SUCCESS;

  do {
    // some logic
    if (condition) {
      error_code = FAILURE;
      break;
    }
    // some logic
  } while (0);

  delete[] a;
  release(other);

  return error_code;
  ```
  Код организует цикл нулевой длины, эксплуатируя возможности языка по
  принудительному выходу из таких циклов. Люди боялись использовать
  `goto` и этот страх породил чудовищ).
- Второй выход известен как _вложенная функция_ - одна функция
  управляет ресурсами: выделяет и освобождает, а другая вызывается в
  первой и отвечает за логику работы с объектами.
  ```cpp
  int foo1 (int *a, int n, res_t other) {
    // some logic
    if (cond)
      reutrn FAILURE;
    return SUCCESS;
  }

  int foo (int n) {
    int *a = new int[n];
    res_t other = query();

    int errcode = foo1(a, n, other);

    delete[] a;
    release(other);

    return errcode;
  }
  ```
  Метод имеет свои недостатки, например, она создает лишний вызов
  функции и запутывает код. _Всего лишь еще одна_ оберточная функция
  прощенная себе десять раз это плюс десять уровней косвенности при
  отладке.
- Третий выход известен как _oksofar trick_. Подход предлагает
  рассматривать функцию как последовательности состояний:
  ```cpp
  int *a = new int[n];
  res_t other = query();
  int error_code = SUCCESS;
  int oksofar = 1;

  // some logic

  if (oksofar) {
    // some logic
    if (cond) {
      errcode = FAILURE;
      oksofar = 0;
    }
  }

  if (oksofar) {
    // some logic
  }

  delete[] a;
  release(other);

  return errcode;
  ```
  Этот **ужас** можно наблюдать в реальных проектах.

### 3.2.1 Идиома RAII

> RAII\
> Resource Acquisition Is Initialization\
> Выделение ресурса это инициализация

Суть в том, что для каждого ресурса создается оберточный объект.
Внутри этого объекта ресурс будет захвачен в конструкторе и освобожден
в деструкторе.

```cpp
struct Buffer {
  Buffer (int n) : m_a (new int[n]) { };
  ~Buffer() { delete[] m_a; }

  int* ptr() const { return m_a; }

private:
  int* m_a;
};

struct Resource {
  Resource() : m_res(query()) { };
  ~Resource() { release(m_res); }

  const res_t& res() const { return m_res; }

private:
  res_t m_res;
}

int foo (int n) {
  Buffer a(n);
  Resource other;

  if (cond)
    return FAILURE;

  return SUCCESS;
}
```

Освобождение ресурсов теперь происходит только в те моменты, когда они
должны происходить. В классах `Buffer` и `Resource` есть одна общая
уязвимость, которая будет пояснена далее (ошибка в конструкторе?)

### 3.2.2 Переопределение копирования

Если мы определим пустой класс
```cpp
class Empty {};
```
то компилятор сам реализует для него конструктор, конструктор
копирования, деструктор и оператор присваивания, т.е.
```cpp
class Empty {
public:
  Empty() { /* default implementation */ }
  Empty (const Empty& rhs) { /* default implementation */ }
  ~Empty() { /* default implementation */ }
  Empty& operator= (const Empty& rhs) { /* default implementation */ }
  // and maybe something else
};
```
Компилятор представляет для класса 6 методов (включая конструктор
перемещения и оператор перемещения).

```cpp
Empty e1;     // ctor
Empty e2(e1); // copy ctor called
e1 = e2;      // copy assignment called
```

Конструктор копирования и оператор присваивания сгенерированные
компилятором побитово копируют код аргумента в целевой объект. Это не
пройдет, если в классе есть член ссылка, тогда нужно написать оператор
присваивания самостоятельно.

**Вопрос** Почему присваивание по умолчанию не годится при членах
класса, являющимися ссылками.\
**Ответ** Потому что произойдет _shallow copy_ вместо _deep copy_. И
члены класса будут ссылаться на одну и ту же область памяти. Это
может привести, например, к тому, что при вызове деструктора одного из
объектов область памяти освободиться. А другой объект об этом знать не
будет.

**Пример** Двойное освобождение
```cpp
class CBuffer {
  char* m_buffer;
  int m_size;

public:
  CBuffer (int size = 10) :
    m_size(size), m_buffer(new char[size]) { }
  ~CBuffer() { delete[] m_buffer; }

  char& get (int x) {
    assert(x >= 0 && x < m_size);
    return m_buffer[x];
  }
};

void BAD (void) {
  CBuffer b1;
  CBuffer b2 = b1;
} /* Segfault here */
```
Во время присваивания `b2 = b1` указатель на буфер из `b1` будет
побитово скопирован в `b2`. Т.е. на один и тот же буфер теперь два
указателя. При выходе из области видимости для обоих буферов `b1` и
`b2` деструктор. Что приведет к двойному освобождению = UB.

По умочанию компилятор реализует _shallow copy_ (побитово),
_deep copy_ всегда пишет сам программист.

```cpp
class Buffer {
public:
  Buffer (int size = 10) :
    m_size(size), m_buffer(new char[size]) { }

  ~Buffer() { delete[] m_buffer; }

  Buffer (const Buffer& rhs) {
    m_size = rhs.m_size;
    m_buffer = new char[m_size];
    memcpy(m_buffer, rhs.m_buffer, m_size);
  }

  char& get (int x) {
    assert(x >= 0 && x < m_size);
    return m_buffer[x];
  }

private:
  char* m_buffer;
  int m_size;
};
```

Однако иногда копирование не нужно и его проще запретить. Чтобы это
сделать нужно объявить конструктор копирования и оператор присваивания
закрытыми члена. Тогда компилятор не сгенерирует неправильные варианты
копирования.

Начиная с C++11 появились ключевые слова `default` и `delete`.
- `default` явно указывает на то, что компилятор сам
  сгенерирует этот метод.
- `delete` явно запрещает компилятору генерировать метод.

**Вопрос** Именно из-за проблемы двойного освобождения в C++ нет и не
может быть простого аналога `realloc`?

Писать RAII-обертку для каждого ресурса накладно. Профессионалы пишут
одну обертку на все типы ресурсов - умные указатели.

### 3.2.3 Оптимизация возвращаемого значения RVO

_RVO (return value optimization)_ заключается в том, что компилятор
имеет право не вызывать копирующие конструкторы если он может
статически доказать, что объекты эквивалентны.

**Пример**
```cpp
struct foo {
  foo() {
    cout << "foo::foo()" << '\n';
  }

  foo (const foo&) {
    cout << "foo::foo(const foo&)" << '\n';
  }

  ~foo() {
    cout << "foo::~foo()" << '\n';
  }
};

foo bar() {
  foo local_foo;
  return local_foo;
}

int main() {
  foo f = bar();
  return 0;
}
```
Если GCC скомпилирует этот код без RVO (-fno-elide-constructors),
вывод будет следующим:
> foo::foo()\
> foo::foo(const foo&)\
> foo::~foo()\
> foo::foo(const foo&)\
> foo::~foo()\
> foo::~foo()

Но если мы разрешим RVO, то вывод будет проще:
> foo::foo()\
> foo::~foo()

Оптимизация RVO разрешена стандартом, поэтому программист не должен
надеяться на то, что его конструктор копирования всегда будет
вызываться в контексте копирования.

## 3.3 Перегрузка операторов
### 3.3.1 Операторы, формирующие цепочки

Пользователь оператора `=` ожидает корректной работы для выражения:
```cpp
a = b = c = d;
```
которое распространяет значение `d` справа налево. Для того, чтобы
такая цепочка могла быть сформированна, оператор `=`  должен
возвращать ссылку на текущий объект.
```cpp
CBuffer& operator= (const CBuffer& rhs) {
  if (&rhs == this) return *this;

  delete[] m_buffer;
  m_size = rhs.m_size;
  m_buffer = new char[m_size];
  memcpy(m_buffer, rhs.m_buffer, m_size);

  return *this;
}
```

Особое внимание нужно обратить на проверку `&rhs == this`. Есть второй
способ выполнить эту проверку: `rhs == *this`. Но он может привести к
неожиданным результатам. Первый способ это сравнение адресов объектов,
второй - это сравнение с помощью оператора `==`, который может быть
переопределен, сравнение объектов с помощью оператора `==` может быть
очень дорогим.

> Большинство цепочечный операций: +=, \*= ... являются модификаторами
  состояния класса, и поэтому должны быть определены внутри класса,
  чтобы у них был доступ к указателю this для возврата.

### 3.3.2 Симметричные бинарные операторы

Наилучший способ определить симметричные бинарные операторы, например,
`operator+` это определить его вне класса через смежный ему цепочечный
оператор. Например,
```cpp
class Complex {
public:
  Complex (double r = 0.0, double i = 0.0) : re(r), im(i) { }

  double get_real() const { return re; }
  double get_imag() const { return im; }
  Complex& operator+= (const Complex& rhs);

private:
  double re;
  double im;
};

Complex operator+ (const Complex& lhs, const Complex& rhs) {
  Complex res = lhs;
  res += rhs;
  return res;
}
```

Это необходимо для того, чтобы мы могли писать:
```cpp
Complex a {-1.3, 8.4};
Complex b;
b = 2.0 + a;
```
Потому что неявные преобразования применяются только к параметрам,
перечисленным в списке параметров. Запись `a + 2.0` вызывает
`a.operator+(2.0)` и у нас есть конструктор, который преобразует
`double` к `Complex`, поэтому здесь происходит неявное преобразование.
А запись `2.0 + a` вызывает `(2.0).operator+(a)` в списке параметров
только объект `a`, поэтому не происходит неявного преобразования `2.0`
к `Complex`. Если мы реализовали оператор сложения вне класса, как
показано выше, то `2.0 + a` вызывает `operator+(2.0, a)`.

Точно также необходимо поступать со всеми функциями, которые по
определению должны быть коммутативными.

### Инкремент и декремент

Постинремент: `x++`.\
Прединкремент: `++x`.

Постинкремент увеличивает значение переменной `x` на единицу и
возвращает ее старое значение. Прединкремент увеличивает переменную
`x` на единицу и возвращает новое значение.

```cpp
Complex& operator++() { // pre-increment
  re += 1.0
  return *this;
}

Complex& operator++(int unused) { // post-increment
  Complex res = *this;
  ++(*this);
  return res;
}
```

### 3.3.4 Вызов и индексация

Эта перегрузка позволяет объекту быть вызванным как функция (с
круглыми скобками и параметрами).
```cpp
class LessThan {
public:
  explicit LessThan (int x = 0) : m_x(x) { }

  bool operator() (int y) { return y < m_x; }

private:
  int m_x;
};
```
Определенный таким образом класс позволяет иметь сразу несколько
функцие-подобных объектов (_функторов_), выражающих предикаты "меньше
x".
```cpp
LessThan lt_three(3), lt_four(4), lt_five(5);

assert(lt_three(2));
assert(!lt_five(10));
```

Использование таких классов я, кажется, видел в `std::map`. Они
нужны были как компараторы для сравнения ключей. Еще я видел их в
сортировке `std::sort` тоже как компараторы.

С индексацией все понятно.

### Разыменование и его варианты

Пусть у нас есть простая структура:
```cpp
struct T {
  int x = 5;
  int foo() { return x; }
};
```

Можно сделать класс, который будет иметировать указатель на эту
структуру.
```cpp
class Tptr {
public:
  Tptr (T* ptr) : m_ptr(ptr) { }
  T operator*() const { return *m_ptr; }
  T* operator->() cosnt { return m_ptr; }

private:
  T* m_ptr;
};
```
Можно использовать.
```cpp
T t;
Tptr pt(&t);
pt->x = 6;
(*pt).foo();
```

Важной особенностью перегрузки оператора стрелки является
_drill-down behaviour_ - зарывающееся поведение: результат стрелки
используется для разрешения имени, но если этого имени нет, то вместо
него снова может быть выбрат вызов стрелки. (Я задавался уже этим
вопросом, когда реализовывал итераторы для `list`).
```cpp
struct client { int a; };

struct proxy {
  client* target;
  client operator->() const { return *target; }
};

struct proxy2 {
  proxy* target;
  proxy& operator->() const { return *target; }
};

void foo() {
  client x { 42 };
  proxy  y { &x };
  proxy2 z { &y };

  printf("%d %d %d\n", x.a, y->a, z->a); // -> 42 42 42
}
```

### 3.3.6 Приведение типов

Для двух любых типов может быть 4 оператора приведения:
- conversion X to Y, declared inside Y; (1)
- conversion X to Y, declared inside X; (2)
- conversion Y to X, declared inside Y; (3)
- conversion Y to X, declared inside X; (4)

при этом каждое из приведений может быть _явным_ или _неявным_.

(1), (4) - обычные конструкторы.

**Пример**
```cpp
struct X {
  X (int) { }       // converting ctor: int -> X
  X (int*) { }      // converting ctor: int* -> X
  X (int(*)[3]) { } // converting ctor: int(*)[3] -> X

  // implicit conversion X -> int
  operator int () const { return 7; }

  // explicit conversion X -> int*
  explicit operator int* () const { return nullptr; }

  // ERROR: array operator not allowed in conversion-type-id
  // operator int(*)[3] () const { return nullptr; }

  // OK or through _typedef_
  using arr_t = int[3];
  operator arr_t* () const { return nullptr; }

  // ERROR: conversion to array not allowed in any case
  // operator arr_t () const;
};
```
Использование
```cpp
X x(1); // init ctor conversion

X x1 = 2; // again init ctor
// call x1.X::operator=(int);
// implicit convertion param int -> X
// call x1.X::operator=(static_cast<X>(int));

X x2 = static_cast<X>(3); // again init ctor

int n = static_cast<int>(x); // OK, explicit X -> int
int m = x;                   // OK, implicit X -> int

int* p = static_cast<int*>(x); // OK, explicit X -> int*
int* q = x;                    // FAIL, no implicit one

int (*pa)[3] = x; // OK
```

Из любого типа можно сделать неявное приведение в любые другие, в том
числе пользовательские
```cpp
struct S {};

struct T {
  operator S();
};
```

**Вопрос** Что я думаю по поводу неявного преобразования к неполным
типам?

## 3.4 Выделение и освобождение динамической памяти

В языке C вся память почти без альтернативно приходит из единственной
фунцкции `malloc`.

Самым близким аналогом функций `malloc` и `free` в C++ являются
глобальные операторы `::operator new` и `::operator delete`. Они
используются каждый раз
- когда в классе не переопределены `new` и `delete`;
- для встроенный типов.

Очень часто `new` и `delete` реализованны через механизмы языка C. Но
между ними есть отличия.

| `malloc` и `free`                                                                                                      | `new` и `delete`                                                                                                                                                                                             |
|------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Память аллоцируется из кучи (heap)                                                                                     | Память аллоцируется из свободного хранилища (free store).  Оно может не совпадать с кучей, это зависит от реализации. Обычно в Unix совпадает, так как используется системный вызов `sbrk`, но есть варианты |
| Возвращаемое значение имеет тип `void*`                                                                                | Возвращаемое значение - типизированный указатель                                                                                                                                                             |
| При неудаче `malloc` возвращает `NULL`                                                                                 | При неудаче обычно выбрасывается исключение                                                                                                                                                                  |
| Требуют указания точного размера в байтах                                                                              | Размер вычисляется компилятором исходя из данного типа                                                                                                                                                       |
| Выделение памяти для массива требует ручного подсчета места на массив                                                  | Есть версия специально для массивов                                                                                                                                                                          |
| Перевыделение памяти просто (нет вызова копирующего конструктора)                                                      | Перевыделение памяти сложно (из-за вызова конструкторов) и нет его стандартной поддержки (аналога `realloc`)                                                                                                 |
| Никогда не вызовут из себя `new` или `delete`                                                                          | Вызовут ли они из себя `malloc` и `free` зависит от реализации                                                                                                                                               |
| Нет способа автоматически разбить запрашиваемую память на мелкие участки при нехватке памяти на большой линейный кусок | Поддерживают установку аллокатора для случая исчерпания памяти через `set_new_handler`                                                                                                                       |
| Не могут быть легально переопределены ни в каком случае                                                                | Могут быть легально переопределены для пользовательских типов                                                                                                                                                |
|                                                                                                                        | Используют конструкторы для инициализации объектов и деструкторы для освобождения их ресурсов                                                                                                                |

### 3.4.2 Стандартный и специальные формы `new`

Типичное выделение памяти в программе на C++
```cpp
class Widget {};
...
Widget* w = new Widget;
```

Предположим, что оператор `new` не переопределен для класса `Widget`.



