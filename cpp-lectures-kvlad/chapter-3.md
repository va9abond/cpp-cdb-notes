# 3. Объектно-ориентированное счастье
## 3.1 Икапсуляция и игра в мячик

Разработаем тип данных для моделирования полета мяча в друмерном мире.
- Мяч может лететь свободно: `fly(double t)`
- Мяч можно толкнуть, придав ему скорость под углом: 
`push(double v, double alpha)`

Начнем с реализации (1)
```cpp
struct ball_t {
  void push (double v, double alpha);
  void fly (double time);

  double t;
  double vx;
  double vy;
  double x;
  double y;
};
```

Проблемы:
- Любой пользователь типа `ball_t` может менять поля объекта, что
может приводить к тому, что поведение мяча может не соответствовать
модели, например, в плохо отлаженной программе он может
телепортироваться
- Если нам понадобиться запустисть этот мяч в многопользовательской
среде, то для того, чтобы вставить синхронизацию, придется переписать
каждый участок кода, где ссылались на поля класса[^1]

[^1]: ?? зачем переписывать и как переписывать?

### 3.1.1 Конкретные классы

*Конкретными классами* называются простые классы без полиморфизма и
наследования.

Реализация (2)
```cpp
struct ball_t {
public:
  void push (double v, double alpha);
  void fly (double time);

prvate:
  double m_t;
  double m_vx;
  double m_vy;
  double m_x;
  double m_y;
};
```

- Модификатор `public` означает, что любой пользователь типа `ball_t`
имеет доступ к этим методам или данным
- Модификатор `private` означает, что доступ к этим методам и данным
имеют только методы этого класса (или друзья класса)
- Хороший тон - закрывать данные, составляющие состояние объекта и
открывать функции, составляющие его поведение

**Вопрос** Если нам доступны методы, открывающие к полю класса чтение
и запись, то не лучше ли вынести это поле `color_` в открытую часть?
```cpp
struct colored_ball_t {
public:
  int get_color() { return color_; }
  void set_color (int color) { color_ = color; }

private:
  int color_;
  // all other
}
```
**Ответ**

**Вопрос** Стрем или норм?
```cpp
struct Bar {
private:
  int foo (int);

public:
  int foo (char);
}

Bar b;
b.foo(1);
```
**Ответ** Целочисленный литерал `1` имеет тип `int`, поэтому
вызовается именно закрытый метод `foo(int)`. А правильно ли позволять
программистам так делать, я не знаю

### 3.1.2 POD и NPOD типы

- Типы со специальным созданием
- Типы со специальным поведением при копировании
- Типы с неизвестным или зависящим от реализации размером
- и тд.

Стандарт (C++14, раздел 9) определяет следующие термины для
обозначения категорий типов, объекты которых могут быть созданы:
- *Тривиально копируемый*
  - непрерывен в памяти
  - не обладает специальным поведением про копировании
  - для таких типов работает `memcpy` и `memmove`
- *Тривиальный*
  - тривиально копируемый
  - без спициального поведения при создании
- *Со стандартным расположением полей*
    - нет зависящих от реализации полей (члены-ссылки, таблицы
      виртуальных методов и тд)
    - такие типы удобны для передачи в модули, написанные на других
      языках, т.к. их всегда можно десериализовать[^2] независимым от
      языка и компилятора образом
- *POD (plain old data)*
  - тривиально копируемый тип со стандартным расоположением полей
- *NPOD (not plain old data)*
  - все, что не является POD типом

[^2]: что это такое?

Типы с закрытой частью остаются тривиально копируемыми

### 3.1.3 Инициализация и уничтожение

Если мы не имеет прямого доступа к полям объекта, то при создании
объект сам должен установить свое состояние, а при уничтожении -
освободить выделенные ресурсы. Для это в класс вводятся конструкторы и
деструктор - специальные функции, вызывающиеся при создании и
уничтожении объекта

```cpp
ball_t (double a_x = 0.0, double a_y = 0.0):
  m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0) {}

~ball_t() {}
```

`m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0)` - называется
*списком инициализации*

Инициализацию можно написать и в теле конструктора, но лучше
использовать список инициализации[^3]

[^3]: почему?

Новизна операторов `new` и `delete` в том, что кроме выделения памяти
на куче, `new` вызывет конструктор, `delete` - деструктор. В отличие
от `malloc`, который только выделит память.
```cpp
ball_t* pball = new ball_t(1.0, 2.0);
// use pball
delete pball;
```

Чтобы получить двадцать мячиков на куче, инициализированных по
умолчанию, вызывается оператор `new[]`, который вызывает конструкторы
для ВСЕХ этих объектов, а еще записывает количество объектор в
специальные структуры памяти, чтобы последующий вызов `delete[]` знал,
сколько деструкторов вызывать
```cpp
ball_t* pballs = new ball_t[20];
// use pballs
delete[] pballs;
```

Выделение памяти и вызов конструктора неразрывны, но
размещающий оператор `new` *(placement new)*, позволяет обойти это
правило.

Часто, конструкторы класса делают почти одно и тоже. В этом случае,
начиная с C++11, конструкторы можно *делегировать*, т.е. вызвать
конструктор этого же класса из списка инициализации
```cpp
class X {
  int a;
public:
  X (int x) : a(x) { /* ... some logic ... */ }
  X (double x) : X(static_cast<int>(x)) { }
};
```

Если инициализация списком утомительна, начиная с C++11 можно
использовать *инициализацию в теле класса*.
```cpp
class A {
  int a = 7;
  int b = 5;
public:
  A() {} // sets a = 7, b = 5
  A(int x) : a(x) {} // sets b = 5
};
```

Неожиданно сложным является вопрос о том, что делать, если в
конструкторе произошла ошибка. Короткий ответ: использовать
инсключения.

### 3.1.4 Неявное преобразование типов и `explicit`

Конструкторы помимо создания объекта класса напрямую используются и
для неявных преобразований типов. Неявные преобразования в C
называются *type promotions*, и некоторые из них действуют и в C++
```
anytype 'op' long double => long double 'op' long double
anytype 'op' double => double 'op' double
anytype 'op' float => float 'op' float
anytype 'op' unsigned long long => unsigned long long 'op' unsigned long long
anytype 'op' long long => long long 'op' long long
anytype 'op' unsigned long => unsigned long 'op' unsigned long
anytype 'op' long => long 'op' long
anytype 'op' unsigned int => unsigned int 'op' unsigned int
anytype 'op' int => int 'op' int
```

Конструкторы с одним аргументом (считая аргументы по умолчанию
частично подставляемые всюду кроме первого аргумента) может быть
использован компилятором для неявного преобразования от типа аргумента
к типу класса. Но это может иметь неприятные последствия
```cpp
int emulate_ball (ball_t b);

int foo() {
  emulate_ball(1.0); // bad, but legal
}
```

Ключевое слово `explicit` перед конструктором запрещает компилятору
использовать неявные преобразования из типа аргумента конструктора к
типу класса
```cpp
explicit ball_t (double a_x = 0.0, double a_y = 0.0):
  m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0) {}
```

Лепить `explicit` куда ни поподя - дурной тон, например, это ключевое
слово возможно в конструкторе с более чем одним аргументом или без
аргументов, но совершенно там не нужно

### 3.1.5 Value-инициализация и Default-инициализация

Тривиальные и нетривиальные типы требуют разной обработки во время
веделения памяти. Когда пользователь пишет
```cpp
int* t = new int; // t uninitialized
int *ts = new int[10]; // pt[.] uninitialized
```
Он не ожидает, что будет вызвано десять конструкторов для целых чисел.
Ожидаемое поведение - десять неинициализированных объектов.
В этом случае никакого конструктора вызвано не будет
```cpp
struct Triv {
  int x
};

Triv *px = new Triv; // x uninitialized
```

Если явно добавить деструктор в структуру, то она перестает быть
тривиальной и для нее будет сгенирирован конструктор по умолчанию
```cpp
struct NTriv {
  int x;
  ~NTriv() {;}
};

NTriv *px = new NTriv; // x initialized with 0
```

Для того, чтобы у тривиальных типов тоже вызывался конструктор
предусмотрели указание пустых скобок для *value-initialization*
```cpp
struct Triv {
  int x;
};

Triv *px = new Triv(); // x initialized with 0
int *t = new int(); // t initialized with 0
int *ts = new int[10](); // 10 ints are initializeda with 0
```

С одной стороны, мы получили запутанность, с другой стороны - аналог
`calloc` для всех тривиальных типов

### 3.1.6 Селекторы

Нужны методы, сохраняющие состояние мяча, но позволяющие прочитать
его. Такие методы называются *селекторами*
```cpp
double get_x() const { return m_x; }
double get_y() const { return m_y; }
```


