# 3. Объектно-ориентированное счастье
## 3.1 Икапсуляция и игра в мячик

Разработаем тип данных для моделирования полета мяча в друмерном мире.
- Мяч может лететь свободно: `fly(double t)`
- Мяч можно толкнуть, придав ему скорость под углом:
  `push(double v, double alpha)`

Начнем с реализации (1)
```cpp
struct ball_t {
  void push (double v, double alpha);
  void fly (double time);

  double t;
  double vx;
  double vy;
  double x;
  double y;
};
```

Проблемы:
- Любой пользователь типа `ball_t` может менять поля объекта, что
  может приводить к тому, что поведение мяча может не соответствовать
  модели, например, в плохо отлаженной программе он может
  телепортироваться
- Если нам понадобиться запустисть этот мяч в многопользовательской
  среде, то для того, чтобы вставить синхронизацию, придется переписать
  каждый участок кода, где ссылались на поля класса[^1]

[^1]: ?? зачем переписывать и как переписывать?

### 3.1.1 Конкретные классы

*Конкретными классами* называются простые классы без полиморфизма и
наследования.

Реализация (2)
```cpp
struct ball_t {
public:
  void push (double v, double alpha);
  void fly (double time);

prvate:
  double m_t;
  double m_vx;
  double m_vy;
  double m_x;
  double m_y;
};
```

- Модификатор `public` означает, что любой пользователь типа `ball_t`
  имеет доступ к этим методам или данным
- Модификатор `private` означает, что доступ к этим методам и данным
  имеют только методы этого класса (или друзья класса)
- Хороший тон - закрывать данные, составляющие состояние объекта и
  открывать функции, составляющие его поведение

**Вопрос** Если нам доступны методы, открывающие к полю класса чтение
и запись, то не лучше ли вынести это поле `color_` в открытую часть?
```cpp
struct colored_ball_t {
public:
  int get_color() { return color_; }
  void set_color (int color) { color_ = color; }

private:
  int color_;
  // all other
}
```
**Ответ**

**Вопрос** Стрем или норм?
```cpp
struct Bar {
private:
  int foo (int);

public:
  int foo (char);
}

Bar b;
b.foo(1);
```
**Ответ** Целочисленный литерал `1` имеет тип `int`, поэтому
вызовается именно закрытый метод `foo(int)`. А правильно ли позволять
программистам так делать, я не знаю.

### 3.1.2 POD и NPOD типы

- Типы со специальным созданием
- Типы со специальным поведением при копировании
- Типы с неизвестным или зависящим от реализации размером
- и тд.

Стандарт (C++14, раздел 9) определяет следующие термины для
обозначения категорий типов, объекты которых могут быть созданы:
- *Тривиально копируемый*
  - непрерывен в памяти
  - не обладает специальным поведением про копировании
  - для таких типов работает `memcpy` и `memmove`
- *Тривиальный*
  - тривиально копируемый
  - без спициального поведения при создании
- *Со стандартным расположением полей*
    - нет зависящих от реализации полей (члены-ссылки, таблицы
      виртуальных методов и тд)
    - такие типы удобны для передачи в модули, написанные на других
      языках, т.к. их всегда можно десериализовать[^2] независимым от
      языка и компилятора образом
- *POD (plain old data)*
  - тривиально копируемый тип со стандартным расоположением полей
- *NPOD (not plain old data)*
  - все, что не является POD типом

[^2]: что это такое?

Типы с закрытой частью остаются тривиально копируемыми.

### 3.1.3 Инициализация и уничтожение

Если мы не имеем прямого доступа к полям объекта, то при создании
объект сам должен установить свое состояние, а при уничтожении -
освободить выделенные ресурсы. Для это в класс вводятся конструкторы и
деструктор - специальные функции, вызывающиеся при создании и
уничтожении объекта.

```cpp
ball_t (double a_x = 0.0, double a_y = 0.0):
  m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0) {}

~ball_t() {}
```

`m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0)` - называется
*списком инициализации*

Инициализацию можно написать и в теле конструктора, но лучше
использовать список инициализации[^3]

[^3]: почему?

Новизна операторов `new` и `delete` в том, что кроме выделения памяти
на куче, `new` вызывет конструктор, `delete` - деструктор. В отличие
от `malloc`, который только выделит память.
```cpp
ball_t* pball = new ball_t(1.0, 2.0);
// use pball
delete pball;
```

Чтобы получить двадцать мячиков на куче, инициализированных по
умолчанию, вызывается оператор `new[]`, который вызывает конструкторы
для ВСЕХ этих объектов, а еще записывает количество объектор в
специальные структуры памяти, чтобы последующий вызов `delete[]` знал,
сколько деструкторов вызывать.
```cpp
ball_t* pballs = new ball_t[20];
// use pballs
delete[] pballs;
```

Выделение памяти и вызов конструктора неразрывны, но
размещающий оператор `new` *(placement new)*, позволяет обойти это
правило.

Часто, конструкторы класса делают почти одно и тоже. В этом случае,
начиная с C++11, конструкторы можно *делегировать*, т.е. вызвать
конструктор этого же класса из списка инициализации:
```cpp
class X {
  int a;
public:
  X (int x) : a(x) { /* ... some logic ... */ }
  X (double x) : X(static_cast<int>(x)) { }
};
```

Если инициализация списком утомительна, начиная с C++11 можно
использовать *инициализацию в теле класса*.
```cpp
class A {
  int a = 7;
  int b = 5;
public:
  A() {} // sets a = 7, b = 5
  A(int x) : a(x) {} // sets b = 5
};
```

Неожиданно сложным является вопрос о том, что делать, если в
конструкторе произошла ошибка. Короткий ответ: использовать
инсключения.

### 3.1.4 Неявное преобразование типов и `explicit`

Конструкторы помимо создания объекта класса напрямую используются и
для неявных преобразований типов. Неявные преобразования в C
называются *type promotions*, и некоторые из них действуют и в C++.
```
anytype 'op' long double => long double 'op' long double
anytype 'op' double => double 'op' double
anytype 'op' float => float 'op' float
anytype 'op' unsigned long long => unsigned long long 'op' unsigned long long
anytype 'op' long long => long long 'op' long long
anytype 'op' unsigned long => unsigned long 'op' unsigned long
anytype 'op' long => long 'op' long
anytype 'op' unsigned int => unsigned int 'op' unsigned int
anytype 'op' int => int 'op' int
```

Конструкторы с одним аргументом (считая аргументы по умолчанию
частично подставляемые всюду кроме первого аргумента) можгут быть
использованы компилятором для неявного преобразования от типа
аргумента к типу класса. Но это может иметь неприятные последствия:
```cpp
int emulate_ball (ball_t b);

int foo() {
  emulate_ball(1.0); // bad, but legal
}
```

Ключевое слово `explicit` перед конструктором запрещает компилятору
использовать неявные преобразования из типа аргумента конструктора к
типу класса.
```cpp
explicit ball_t (double a_x = 0.0, double a_y = 0.0):
  m_x(a_x), m_y(a_y), m_vx(0.0), m_vy(0.0), m_t(0.0) {}
```

Лепить `explicit` куда ни поподя - дурной тон, например, это ключевое
слово возможно в конструкторе с более чем одним аргументом или без
аргументов, но совершенно там не нужно.

### 3.1.5 Value-инициализация и Default-инициализация

Тривиальные и нетривиальные типы требуют разной обработки во время
веделения памяти. Когда пользователь пишет
```cpp
int *t = new int; // t uninitialized
int *ts = new int[10]; // pt[.] uninitialized
```
Он не ожидает, что будет вызвано десять конструкторов для целых чисел.
Ожидаемое поведение - десять неинициализированных объектов.
В этом случае никакого конструктора вызвано не будет.
```cpp
struct Triv {
  int x
};

Triv *px = new Triv; // x uninitialized
```

Если явно добавить деструктор в структуру, то она перестает быть
тривиальной и для нее будет сгенирирован конструктор по умолчанию.
```cpp
struct NTriv {
  int x;
  ~NTriv() {;}
};

NTriv *px = new NTriv; // x initialized with 0
```

Для того, чтобы у тривиальных типов тоже вызывался конструктор
предусмотрели указание пустых скобок для *value-initialization*
```cpp
struct Triv {
  int x;
};

Triv *px = new Triv(); // x initialized with 0
int *t = new int(); // t initialized with 0
int *ts = new int[10](); // 10 ints are initializeda with 0
```

С одной стороны, мы получили запутанность, с другой стороны - аналог
`calloc` для всех тривиальных типов

### 3.1.6 Селекторы

Нужны методы, сохраняющие состояние мяча, но позволяющие прочитать
его. Такие методы называются *селекторами*.
```cpp
double get_x() const { return m_x; }
double get_y() const { return m_y; }
```

`const` в определении указывает, что изменение любого поля класса
внутри метода вызовет ошибку компиляции. Исключением составляют поля,
объявленные с ключевым словом `mutable`, ими не стоит злоупотреблять в
проектировании.

**Вопрос** Найти нетривиальный случай, когда ключевое слово `mutable`
полезно и оправдано.

Лучше делать селектором любой метод, который может быть селектором
теоретически и который не должен менять внутреннего состояния объекта.
Это позволяет дополнительные оптимизации в компиляторе и аннотирует
метод важной информацией для дальнейшего использования.

### 3.1.7 Статические члены в классе

Каждый объект класса имеет свои собственные копии полей класса
`this->x`. Именно поэтому методы структуры и класса неявно берут
первым аргументом указатель на тот объект, для которого они будут
вызваны, а иначе как они поймут с полями какого из объектов класса
взаимодействовать.

И все же, иногда нужно иметь общий атрибут[^4] для всех объектов. В
этом случае используют ключевое слово `static`, которое в контексте
класса обозначает, что методы и данные не зависят от `this` и являются
общими для всех объектов класса.

[^4]: Атрибут - данные класса, образующие его состояние (это может
    быть поле или метод).

```cpp
class ball {
  int x, y;
  static int ball_count;

public:
  ball() : x(0), y(0) {
    ball_count += 1;
  }

  static int get_count() {
    return ball_count;
  }
}; int ball::ball_count = 0;
```

Статический метод класса `get_count()` не отмечен как `const`.
Статические методы не могут быть отмечены ключевым словом `const`,
потому что поскольку у таких методов нет объекта класса, они не могут
изменять состояние ни одного объекта.

Статические методы класса не сильно отличаются от глобальных. У первых
есть доступ к закрытому *статическому* атрибуту. Точно так же и
статические поля не сильно отличаются от глобальных переменных.

Статические поля должны быть инициализированны вне класса, этого
нельзя делать в конструкторе, потому что статические члены должны быть
доступны, даже если не было создано ни одного объекта.

Дополнительное определение где-то вне класса требутеся даже если
инициализация не требуется.
```cpp
struct S {
  statix int x;
};

int S::x;
```
Это связано с тем, что в конструкторе выделение памяти для полей
объектов класса и их полей не происходит (это случается в операторе
`new` перед тем, как конструктор будет вызван), но память должна
где-то быть выделена. Надо быть осторожнее с ODR - плохая идея делать
это в заголовочнике[^5].

[^5]: почему?

Исключение сделано для статических констант внутри класса. Они могут
быть инициализированны по месту объявления.

### 3.1.8 Указатели на методы класса

Пусть мы имеем класс:
```cpp
struct MyClass {
  int do_it (float a, float b) const;
};
```
Тогда тип *указатель на константный метод* может быть записан:
```cpp
typedef int (MyClass::*do_it_ptr)(float, int) const; // (var. 1)
using do_it_ptr = int (MyClass::*)(float, int) const; // (var. 2)
```
Звездочка после `::` является частью синтаксиса. А теперь может это
использовать:
```cpp
do_it_ptr ptr = &MyClass::do_it;
MyClass c;
(c.*ptr)(1.0, 0);

// or

MyClass *d = &c;
(d->*ptr)(1.0, 0);
```

### 3.1.9 Объявления и определения классов

*Объявление* класса как неполного типа:
```cpp
class ball_t;
```
С этого момента тип `ball_t` можно использовать по правалам (из
стандарта) для неполных типов.

*Определение* класса - это объвление всех его методов и полей. Но
внутри определения класса, каждое объявление поля, стат. поля или
метода - это *объявление*.
- Определением нестат. члена - конструктор клсса;
- Определение метода может встречаться как внутри класса, так и быть
  вынесено вне его;
- Определение статического объекта всегда должно быть вне класса.

## 3.2 Классы для управления ресурсами

**Вопрос** Какие есть ресурсы кроме динамической памяти?

Что общего у всех этих ресурсов? Как правило - наличие парных команд
для запроса и освобождения, например:
- `new` и `delete` для динамической памяти;
- `fopen` и `fclose` для файлов;
- `mysql_real_connect` и `mysql_close` для запросов MySQL C API;
- `pthread_mutex_init` и `pthread_mutex_destroy` для работы с
  мьютексами в POSIX.
В общем случае можно говорить о паре функций: `query` для запроса
ресурса и `release` для освобождения ресурса.

**Пример**
```cpp
int foo (int n) {
  int *a = new int[n];
  res_t other = query();

  // some logic

  if (condition) {
    delete[] a;
    release (other);
    return FAILURE;
  }

  // some logic

  delete[] a;
  release (other);
  return SUCCESS;
}
```
Проблема в том, что код освобождения ресурсов дублируется и часто в
непредсказуемых местах. Какие решения этой проблемы используют в
_legacy code_ на языке C.

- Лучший выход, применяемый в ядре Linux, это использование в таких
  случаях `goto`
  [(link)](https://www.kernel.org/doc/Documentation/process/coding-style.rst).
  ```cpp
  int *a = new int[n];
  res_t other = query();
  int error_code = SUCCESS;

  // some logic

  if (condition) {
    error_code = FAILURE;
    goto cleanup;
  }

  // some logic

  cleanup:
  delete[] a;
  release(other);

  return error_code;
  ```
- Другая реализация этого подхода это использовать `do-while`, который
  позволяет организовать `goto` без явного `goto`.
  ```cpp
  int *a = new int[n];
  res_t other = query();
  int error_code = SUCCESS;

  do {
    // some logic
    if (condition) {
      error_code = FAILURE;
      break;
    }
    // some logic
  } while (0);

  delete[] a;
  release(other);

  return error_code;
  ```
  Код организует цикл нулевой длины, эксплуатируя возможности языка по
  принудительному выходу из таких циклов. Люди боялись использовать
  `goto` и этот страх породил чудовищ).
- Второй выход известен как _вложенная функция_ - одна функция
  управляет ресурсами: выделяет и освобождает, а другая вызывается в
  первой и отвечает за логику работы с объектами.
  ```cpp
  int foo1 (int *a, int n, res_t other) {
    // some logic
    if (cond)
      reutrn FAILURE;
    return SUCCESS;
  }

  int foo (int n) {
    int *a = new int[n];
    res_t other = query();

    int errcode = foo1(a, n, other);

    delete[] a;
    release(other);

    return errcode;
  }
  ```
  Метод имеет свои недостатки, например, она создает лишний вызов
  функции и запутывает код. _Всего лишь еще одна_ оберточная функция
  прощенная себе десять раз это плюс десять уровней косвенности при
  отладке.
- Третий выход известен как _oksofar trick_. Подход предлагает
  рассматривать функцию как последовательности состояний:
  ```cpp
  int *a = new int[n];
  res_t other = query();
  int error_code = SUCCESS;
  int oksofar = 1;

  // some logic

  if (oksofar) {
    // some logic
    if (cond) {
      errcode = FAILURE;
      oksofar = 0;
    }
  }

  if (oksofar) {
    // some logic
  }

  delete[] a;
  release(other);

  return errcode;
  ```
  Этот **ужас** можно наблюдать в реальных проектах.

### 3.2.1 Идиома RAII

> RAII
> Resource Acquisition Is Initialization
> Выделение ресурса это инициализация

Суть в том, что для каждого ресурса создается оберточный объект.
Внутри этого объекта ресурс будет захвачен в конструкторе и освобожден
в деструкторе.

```cpp
struct Buffer {
  Buffer (int n) : m_a (new int[n]) { };
  ~Buffer() { delete[] m_a; }

  int* ptr() const { return m_a; }

private:
  int* m_a;
};

struct Resource {
  Resource() : m_res(query()) { };
  ~Resource() { release(m_res); }

  const res_t& res() const { return m_res; }

private:
  res_t m_res;
}

int foo (int n) {
  Buffer a(n);
  Resource other;

  if (cond)
    return FAILURE;

  return SUCCESS;
}
```

Освобождение ресурсов теперь происходит только в те моменты, когда они
должны происходить. В классах `Buffer` и `Resource` есть одна общая
уязвимость, которая будет пояснена далее (ошибка в конструкторе?)

### 3.2.2 Переопределение копирования

Если мы определим пустой класс
```cpp
class Empty {};
```
то компилятор сам реализует для него конструктор, конструктор
копирования, деструктор и оператор присваивания, т.е.
```cpp
class Empty {
public:
  Empty() { /* default implementation */ }
  Empty (const Empty& rhs) { /* default implementation */ }
  ~Empty() { /* default implementation */ }
  Empty& operator= (const Empty& rhs) { /* default implementation */ }
  // and maybe something else
};
```
Компилятор представляет для класса 6 методов (включая конструктор
перемещения и оператор перемещения).

```cpp
Empty e1;     // ctor
Empty e2(e1); // copy ctor called
e1 = e2;      // copy assignment called
```

Конструктор копирования и оператор присваивания сгенерированные
компилятором побитово копируют код аргумента в целевой объект. Это не
пройдет, если в классе есть член ссылка, тогда нужно написать оператор
присваивания самостоятельно.

**Вопрос** Почему присваивание по умолчанию не годится при членах
класса, являющимися ссылками.\
**Ответ** Потому что произойдет _shallow copy_ вместо _deep copy_. И
члены класса будут ссылаться на одну и ту же область памяти. Это
может привести, например, к тому, что при вызове деструктора одного из
объектов область памяти освободиться. А другой объект об этом знать не
будет.

**Пример** Двойное освобождение
```cpp
class CBuffer {
  char* m_buffer;
  int m_size;

public:
  CBuffer (int size = 10) :
    m_size(size), m_buffer(new char[size]) { }
  ~CBuffer() { delete[] m_buffer; }

  char& get (int x) {
    assert(x >= 0 && x < m_size);
    return m_buffer[x];
  }
};

void BAD (void) {
  CBuffer b1;
  CBuffer b2 = b1;
} /* Segfault here */
```
Во время присваивания `b2 = b1` указатель на буфер из `b1` будет
побитово скопирован в `b2`. Т.е. на один и тот же буфер теперь два
указателя. При выходе из области видимости для обоих буферов `b1` и
`b2` деструктор. Что приведет к двойному освобождению = UB.

По умочанию компилятор реализует _shallow copy_ (побитово),
_deep copy_ всегда пишет сам программист.

```cpp
class Buffer {
public:
  Buffer (int size = 10) :
    m_size(size), m_buffer(new char[size]) { }

  ~Buffer() { delete[] m_buffer; }

  Buffer (const Buffer& rhs) {
    m_size = rhs.m_size;
    m_buffer = new char[m_size];
    memcpy(m_buffer, rhs.m_buffer, m_size);
  }

  char& get (int x) {
    assert(x >= 0 && x < m_size);
    return m_buffer[x];
  }

private:
  char* m_buffer;
  int m_size;
};
```

Однако иногда копирование не нужно и его проще запретить. Чтобы это
сделать нужно объявить конструктор копирования и оператор присваивания
закрытыми члена. Тогда компилятор не сгенерирует неправильные варианты
копирования.

Начиная с C++11 появились ключевые слова `default` и `delete`.
- `default` явно указывает на то, что компилятор сам
  сгенерирует этот метод.
- `delete` явно запрещает компилятору генерировать метод.

**Вопрос** Именно из-за проблемы двойного освобождения в C++ нет и не
может быть простого аналога `realloc`?

Писать RAII-обертку для каждого ресурса накладно. Профессионалы пишут
одну обертку на все типы ресурсов - умные указатели.

### 3.2.3 Оптимизация возвращаемого значения RVO

_RVO (return value optimization)_ заключается в том, что компилятор
имеет право не вызывать копирующие конструкторы если он может
статически доказать, что объекты эквивалентны.

**Пример**
```cpp
struct foo {
  foo() {
    cout << "foo::foo()" << '\n';
  }

  foo (const foo&) {
    cout << "foo::foo(const foo&)" << '\n';
  }

  ~foo() {
    cout << "foo::~foo()" << '\n';
  }
};

foo bar() {
  foo local_foo;
  return local_foo;
}

int main() {
  foo f = bar();
  return 0;
}
```
Если GCC скомпилирует этот код без RVO (-fno-elide-constructors),
вывод будет следующим:
> foo::foo()
> foo::foo(const foo&)
> foo::~foo()
> foo::foo(const foo&)
> foo::~foo()
> foo::~foo()

Но если мы разрешим RVO, то вывод будет проще:
> foo::foo()
> foo::~foo()

Оптимизация RVO разрешена стандартом, поэтому программист не должен
надеяться на то, что его конструктор копирования всегда будет
вызываться в контексте копирования.

## 3.3 Перегрузка операторов
